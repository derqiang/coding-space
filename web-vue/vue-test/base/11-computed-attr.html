<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>blank page</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <style rel="stylesheet">
    </style>
    <script type="application/javascript">
        window.onload = function () {
            this.app = new Vue({
                el: '#app',
                data: {
                    message: 'hello!',
                    msg: 'world',
                    firstName: 'da',
                    lastName: 'qiang',
                },
                computed: {
                    reversedMessage: function () {
                        console.log('computed call')
                        console.log(this.message)
                        return this.message.split('').reverse().join('') + this.msg
                    },
                    fullName: {
                        get: function () {
                            return this.firstName + ' ' + this.lastName;
                        },
                        set: function (newValue) {
                            var names = newValue.split(' ')
                            this.firstName = names[0]
                            this.lastName = names[1]
                        }
                    }
                },
                methods: {
                    reverseMessageF: function () {
                        console.log('method call')
                        return this.message.split('').reverse().join('')
                    }
                }
            })
        }
    </script>
</head>
<body>
    <div id="app">
        <p>Original Message: {{ message + msg }}</p>
        <p>Reversed Message: {{ reversedMessage }}</p>
        <p>方法调用: {{ reverseMessageF() }} , 方法不会有缓存，次次计算，计算属性只有在相关联和依赖的属性发生变化时才计算(<span style="color: red;">这里存疑问，实际验证得知 方法和计算属性都是依赖属性变化时候才触发</span>) </p>

        <p>计算属性默认是getter方法，可以显式声明 set 和 get</p>
        <p>{{ fullName }}</p>
        <a href="./11.1-computed-attr.html">计算属性和侦听属性</a>
    </div>
</body>
</html>
